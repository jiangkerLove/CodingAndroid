布局优化：

- 改进自定义的View，界面中大量使用的输入框都是由LinearLayout来封装的。因为EditText都是有drawable的，所以改为自定义的EditText减少布局层级。

- 使用include、merge、viewstub来优化布局层级以及延迟加载。

-  使用约束布局来更改界面中的复杂布局

- 布局中多使用精确尺寸，例如match_parent以及dp，减少测量次数。

- 分步加载，对于特别复杂的一个界面，在进入界面之后先显示整体框架，然后再展示的输入框中的数据。

- 其他： 
  - onDraw方法中不能new 对象，因为频繁调用，容易造成内存抖动。
  - 使用SpannableString来代替多个连续的textview。
  - IntArray减少自动装箱

计算优化：

- 关于矢量计算过程的优化，因为向量是方向和长度需要分解为实部和虚部去计算，之前是每次计算时先分解然后又转换回去，优化之后为每当要获取方向和长度时才转换回去，否则都是保存实部和虚部，因为绘制矢量图也是用的实部和虚部，所以计算速度大大提升了好几倍。

卡顿优化：

- 程序大多数界面为上部分为实验条目区，下部分为输入区，界面在弹出软键盘时，需要对实验条目区进行隐藏，然后这个过程很卡顿，之前的做法是监听软键盘，弹出或隐藏之后立刻进行隐藏调用，复杂的界面大概需要1.5秒左右。然后对最外层layout的方法进行调用打印，发现draw方法被调用了三次，然后在layout的时候记录view高度，变化measure的高度变化了之后直接这里回调隐藏view，使最后draw方法只调用了一次，优化之后大概0.6秒左右可以完成。



启动速度优化：

- 因为启动往往需要加载比较多的三方库，可以对初始化的代码进行一层包装，然后再使用协程或者线程池来异步加载。需要区分哪些可以放在子线程哪些不能，哪些直接有顺序关系以及异步线程数不要多余CPU核心数了。

内存抖动优化

- 尽量避免在循环体内创建对象
- view的onDraw()方法会被频繁调用，使用切勿在这里创建对象。
- 当需要大量使用bitmap时，可以把他们缓存起来。
- 对于能够复用的对象，可以使用缓存起来从中去获取。

内存泄漏

- recyclerview泄漏
- spannablestring泄漏
- 单例内存泄漏
- handler内存泄漏 - 队列中的message持有handler的引用，而handler持有activity的引用就会造成泄漏。